# [RailsStart](https://github.com/the-teacher/rails-start): Как Makefile помогает Rails разработчику

<img src="../images/rails-start-banner-2.webp" alt="Rails Start" />

## Введение

Несколько лет назад мне потребовался быстрый плейграунд для запуска **Rails** приложений для новых проектов и экспериментов. Также я записываю видео лекции и мастер-классы по **Rails**, и мне нужен был проект, где слушатели моих программ смогли бы отрабатывать свои навыки.

Так был создан проект **[RailsStart](https://github.com/the-teacher/rails-start)**, который позволяет запускать **Rails** приложения быстро, почти мгновенно.

**Главная цель проекта** - позволить запускать **Rails** на любой операционной системе буквально одной командой.

В этой статье я расскажу о важности `Makefile` для реализации моего проекта. В основе его архитектуры лежит элегантное использование `Makefile` - инструмента, который превращает сложные **Docker** и **Rails** команды в простые и понятные вызовы.

## Что такое Make и Makefile?

**Make** - это утилита автоматизации сборки, которая управляет процессом компиляции и сборки программного обеспечения. Она использует файл под названием **Makefile**, в котором описаны правила и зависимости для сборки проекта.

**`Makefile`** - это текстовый файл, содержащий набор инструкций для утилиты **Make**.

`Makefile` обычно используется в **C/C++** проектах для компиляции, в системном администрировании для автоматизации задач, в **DevOps** для управления развертыванием и в различных проектах для стандартизации команд разработки.

В моем проекте **Make** и `Makefile` имеют важное значение. Эти инструменты позволяют мне автоматизировать подготовку проекта и запуск **Rails** приложения.

Благодаря простоте **Make** в моем проекте запуск **Rails** приложения выполняется просто, элегантно и буквально одной командой.

## Что нужно чтобы запустить [Rails Start](https://github.com/the-teacher/rails-start)?

Для запуска [Rails Start](https://github.com/the-teacher/rails-start) требуется всего три привычных любому разработчику инструмента:

- **Git** - для получения проекта с **GitHub**
- **Make** - чтобы запустить автоматический процесс установки
- **Docker** - чтобы запустить приложение в контейнере

Если эти инструменты доступны в вашей операционной системе, то можно считать, что **Rails** приложение будет установлено у вас менее чем за 5 минут.

## Почему я использую **Make** а не **Ruby** скрипты?

Первая версия проекта полагалась на скрипты автоматизации и запуска, основанные на **Ruby** технологиях.

Однако чтобы сделать процесс универсальным и для хост-машины, где **Ruby** может быть не установлен, я перешел на использование популярного **Make**, который может использоваться как на хост-машине, так и в контейнере.

**Преимущества Make над Ruby скриптами:**

- **Универсальность** - **Make** доступен практически на всех **Unix**-системах
- **Независимость** - не требует установки **Ruby** на хост-системе
- **Простота** - понятный синтаксис для автоматизации команд
- **Стандартность** - привычный инструмент для разработчиков

## Двухуровневая архитектура `Makefiles`

Ключевая особенность [RailsStart](https://github.com/the-teacher/rails-start) заключается в **двухуровневой системе `Makefiles`**:

В проекте [RailsStart](https://github.com/the-teacher/rails-start) используются 2 уровня `Makefiles`. Один уровень рассчитан на использование на уровне хост-системы (компьютера, на котором вы работаете), второй уровень `Makefiles` рассчитан на использование внутри **Docker**-контейнера.

Я стараюсь придерживаться унифицированных и единообразных имен команд, чтобы на разных уровнях был доступен запуск идентичных команд примерно с использованием идентичных **Make** команд.

### 1. Уровень хоста (проекта)

**Расположение:** `/Makefiles/`

Этот уровень отвечает за управление **Docker**-контейнерами и оркестрацию всего проекта. Команды на уровне хоста автоматически делегируют выполнение в соответствующие контейнеры, обеспечивая единообразный интерфейс:

```makefile
# Простой запуск всего проекта
make rails-start

# Управление контейнерами
make start    # Запуск контейнеров
make stop     # Остановка контейнеров
make status   # Статус контейнеров

# Делегирование Rails команд в контейнер
make rails-console     # Открыть Rails консоль
make rails-db-migrate  # Запустить миграции
make rails-server      # Запустить Rails сервер
```

**Основные функции:**

- Управление **Docker Compose**
- Настройка окружения проекта
- Делегирование команд в контейнеры
- Организация файловой структуры
- Унифицированный интерфейс для всех операций

### 2. Уровень контейнера

**Расположение:** `/__RailsApp__/Makefiles/`

Этот уровень содержит команды, которые выполняются непосредственно внутри **Rails**-контейнера. Команды имеют аналогичные имена с командами хоста, но выполняются в контексте контейнера:

```makefile
# Команды внутри контейнера
make setup      # Настройка Rails приложения
make console    # Rails консоль
make db-migrate # Миграции базы данных
make server     # Запуск Rails сервера
make bundle     # Установка gem'ов
```

**Основные функции:**

- **Rails**-специфичные команды
- Управление базой данных
- Работа с зависимостями (**bundler**)
- Генераторы и тестирование
- Прямое выполнение в контексте **Rails** приложения

## Модульная структура

Каждый уровень организован наборами Makefile файлов с определенным назначением для лучшей структуры и поддержки:

```
rails-start/
├── Makefiles/                    # Уровень хоста
│   ├── 100_Project.mk           # Управление Docker и проектом
│   ├── 200_Rails.mk             # Делегирование Rails команд
│   ├── 300_Rails-Production.mk  # Продакшн окружение
│   └── 400_env.mk               # Управление переменными окружения
│
└── __RailsApp__/
    └── Makefiles/               # Уровень контейнера
        ├── 100_Project.mk       # Общие команды контейнера
        ├── 200_Rails.mk         # Rails разработка
        └── 300_Production.mk    # Продакшн команды
```

### Уровень хоста:

- `100_Project.mk` - Управление Docker и проектом
- `200_Rails.mk` - Делегирование Rails команд
- `300_Rails-Production.mk` - Продакшн окружение
- `400_env.mk` - Управление ENV переменными окружения

### Уровень контейнера:

- `100_Project.mk` - Общие команды контейнера
- `200_Rails.mk` - Rails разработка
- `300_Production.mk` - Продакшн команды

## Преимущества такого подхода

### 1. **Единообразие команд на разных уровнях**

Благодаря унифицированным именам команд, разработчик может использовать схожие команды как на хосте, так и внутри контейнера:

```bash
# На хосте
make rails-console     # Делегирует в контейнер
make rails-db-migrate  # Делегирует в контейнер

# Внутри контейнера (после make rails-bash)
make console           # Выполняется напрямую
make db-migrate        # Выполняется напрямую
```

### 2. **Простота использования**

```bash
# Вместо сложной команды:
docker compose -f ./docker/docker-compose.yml exec rails_app bundle exec rails db:migrate

# Достаточно:
make rails-db-migrate
```

### 3. **Унификация команд между операционными системами**

Независимо от того, работаете ли вы на **macOS**, **Linux** или **Windows** (через **WSL**), команды остаются одинаковыми.

### 3. **Самодокументирование**

```bash
make help                   # Общая справка
make rails-help             # Rails команды
make project-help           # Управление проектом
make rails-production-help  # Продакшн команды
```

### 4. **Прозрачное делегирование команд**

Команды хоста автоматически делегируются в контейнер, сохраняя единообразие интерфейса:

```makefile
# На хосте (Makefiles/200_Rails.mk)
rails-console:
	docker compose -f $(COMPOSE_FILE) exec rails_app make console

rails-db-migrate:
	docker compose -f $(COMPOSE_FILE) exec rails_app make db-migrate

# В контейнере (__RailsApp__/Makefiles/200_Rails.mk)
console:
	bundle exec rails console

db-migrate:
	bundle exec rails db:migrate
```

Такая архитектура позволяет разработчику не думать о том, где именно выполняется команда - система автоматически выберет правильный контекст.

## Практические примеры

### Быстрый старт проекта:

```bash
git clone https://github.com/the-teacher/rails-start.git
cd rails-start
make rails-start  # Всё готово!
```

### Ежедневная разработка:

```bash
make rails-console     # Открыть Rails консоль
make rails-db-migrate  # Запустить миграции
make rails-logs        # Посмотреть логи
make rails-status      # Проверить процессы
```

### Работа с базой данных:

```bash
make rails-db-create   # Создать БД
make rails-db-seed     # Заполнить данными
make rails-db-reset    # Полный сброс (с предупреждением)
```

### Генераторы и тестирование:

```bash
make rails-bash                             # Войти в контейнер
make generate-model name=User               # Создать модель
make generate-controller name=Users         # Создать контроллер
make test                                   # Запустить тесты
```

## Заключение

`Makefile` не часто встречается в **Rails** проектах, и эта технология не очень распространена для работы с **Rails** приложениями. Однако проект [RailsStart](https://github.com/the-teacher/rails-start) показывает пример эффективного и элегантного решения для запуска **Rails** на любой операционной системе.

`Makefile` в проекте [RailsStart](https://github.com/the-teacher/rails-start) не просто упрощает команды - он создаёт **единый интерфейс управления** для всего жизненного цикла **Rails** приложения.

Двухуровневая архитектура обеспечивает четкое разделение ответственности между управлением инфраструктурой (хост) и разработкой приложения (контейнер).

Это решение особенно ценно для:

- **Команд разработчиков** - унификация рабочих процессов
- **Новых участников проекта** - быстрое понимание доступных команд
- **DevOps практик** - стандартизация развёртывания
- **Обучения Rails** - фокус на разработке, а не на настройке окружения

[RailsStart](https://github.com/the-teacher/rails-start) доказывает, что правильно организованный `Makefile` может превратить сложную **Docker** + **Rails** среду в простой и интуитивно понятный инструмент разработки.

---

## Тезаурус

**Хост-машина** - физический или виртуальный компьютер, на котором запускается Docker и другое программное обеспечение. В контексте статьи - ваша рабочая машина (macOS, Linux, Windows).

**Контейнер** - изолированная среда выполнения приложений, созданная с помощью технологии контейнеризации. Содержит приложение и все его зависимости.

**Docker** - платформа для разработки, доставки и запуска приложений в контейнерах. [docker.com](https://www.docker.com/)

**Docker Compose** - инструмент для определения и запуска многоконтейнерных Docker приложений. [docs.docker.com/compose](https://docs.docker.com/compose/)

**Make** - утилита автоматизации сборки для управления компиляцией и выполнением команд. [gnu.org/software/make](https://www.gnu.org/software/make/)

**Makefile** - файл конфигурации для утилиты Make, содержащий правила и команды для автоматизации задач.

**Rails (Ruby on Rails)** - веб-фреймворк для языка программирования Ruby. [rubyonrails.org](https://rubyonrails.org/)

**Git** - распределённая система управления версиями. [git-scm.com](https://git-scm.com/)

**WSL (Windows Subsystem for Linux)** - подсистема Windows для Linux, позволяющая запускать Linux окружение на Windows. [docs.microsoft.com/windows/wsl](https://docs.microsoft.com/en-us/windows/wsl/)
